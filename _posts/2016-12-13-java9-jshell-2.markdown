---
layout:     post
title:      "Java9 - jshell [2]"
date:       2016-12-4
categories: java9 jshell
---

In [first part] we've looked on absolute basics of **JShell**. Now I'm going show another features that help you customize **JShell** and make work with it more easy and fun.

<!--more-->

![jshell]({{ site.url }}/assets/jshell/jshell.png) 

## Tab completion
No-one can remember every method in every class and programmers are by nature lazy people. You're probably used to tab completion from your linux/osx/windows/whatever terminal and good news is that **JShell** can do it too. So let's look

{% highlight java %}
jshell> System.
Logger                 LoggerFinder           arraycopy(             class                  
clearProperty(         console()              currentTimeMillis()    err                    
exit(                  gc()                   getLogger(             getProperties()        
getProperty(           getSecurityManager()   getenv(                identityHashCode(      
in                     inheritedChannel()     lineSeparator()        load(                  
loadLibrary(           mapLibraryName(        nanoTime()             out                    
runFinalization()      runFinalizersOnExit(   setErr(                setIn(                 
setOut(                setProperties(         setProperty(           setSecurityManager(    

jshell> System.out.
append(        checkError()   close()        equals(        flush()        format(        
getClass()     hashCode()     notify()       notifyAll()    print(         printf(        
println(       toString()     wait(          write(         

jshell> System.out.print
print(     printf(    println(   

jshell> System.out.println(
println(   

jshell> System.out.println(
{% endhighlight %}

As you can see, **JShell** helps with listing methods. When I write `System.` and hit `Tab`, I'll get list of all methods. I can start writing method name, like `System.out.print` and I'll get all methods that starts with `..print`. If only one option left, **JShell** complete that option for me. For example `System.out.printl` + `Tab` -> `System.out.println(`.

Of course it works with all classes. Let's use class from first part of article

{% highlight java %}
jshell> class Square {
   ...> private int side;
   ...> Square(int side) { this.side = side; }
   ...> int perimeter() { return 4 * side; }
   ...> int area() { return side * side; }
   ...> }
|  created class Square

jshell> Square s = new Square(4)
s ==> Square@5622fdf

jshell> s.
area()        equals(       getClass()    hashCode()    notify()      notifyAll()   
perimeter()   toString()    wait(
{% endhighlight %}

## JShell commands
So far we used just java "commands". However, **JShell** can accept another type of commands. These always start with `/` and it means that I'm talking to **JShell**. Every other case means that I'm talking to **JVM**.

So let's look what it offers. Of course tab completion works
{% highlight java %}
jshell> /
/!            /?            /classpath    /drop         /edit         /exit         
/help         /history      /imports      /list         /methods      /open         
/reload       /reset        /save         /set          /types        /vars
{% endhighlight %}

`/help` is useful but too long output, you may try it yourself. For each command you can use `/help [command]` (e.g. `/help /list`) and you'll see detailed help for given command.

### customize
There are 4 predefined modes of verbosity *silent*, *concise*, *normal* and *verbose*. Default is *normal*. If you want slight less verbosity, *concise* is a good choice. You can also set your own profile, there are many configuration options.


**Normal** is used in all previous examples. It's little too stretched to my taste, but it's ok default choice.
{% highlight java %}
jshell> /set feedback normal
|  Feedback mode: normal

jshell> 5
$13 ==> 5

jshell> int i = 6
i ==> 6

jshell> i
i ==> 6

jshell> System.out.println("Hello")
Hello
{% endhighlight %}


**Concise** is my favorite. It's more compact, but still prints all what I need.
{% highlight java %}
jshell> /set feedback concise 
jshell> 5
$9 ==> 5
jshell> int i = 6
jshell> i
i ==> 6
jshell> System.out.println("Hello")
Hello
{% endhighlight %}


In **silent** mode you can't even see implicit variables, even when you want to see variable value you have to print it.
{% highlight java %}
jshell> /set feedback silent
-> 5
-> int i = 6
-> i
-> System.out.println("Hello")
Hello
{% endhighlight %}


**Verbose** is in my opinion too chatty. It basically writes in second line meaning of the first line so maybe for newbies it might be useful.
{% highlight java %}
jshell> /set feedback verbose
|  Feedback mode: verbose

jshell> 5
$5 ==> 5
|  created scratch variable $5 : int

jshell> int i = 6
i ==> 6
|  modified variable i : int
|    update overwrote variable i : int

jshell> i
i ==> 6
|  value of i : int

jshell> System.out.println("Hello")
Hello
{% endhighlight %}


**JShell** is much more customizable. To see more details check `/help /set` and you'll see many many options.


### /history /list
Command `/history` prints all commands you have entered so far

{% highlight java %}
jshell> /history

int a = 5
class Point {
int x;
int y;
Point(int x, int y) {
this.x = x;
this.y = y;
}
}
Point p = new Point(2,4)
p.x
/drop a
a
/history
{% endhighlight %}

That's nothing surprising. Very similar is `/list`, but here I can see the source of snippets and only valid ones. So if I dropped variable `a`, I can see it in `/history`, but not in `/list`
{% highlight java %}
jshell> /list

   2 : class Point {
       int x;
       int y;
       Point(int x, int y) {
       this.x = x;
       this.y = y;
       }
       }
   3 : Point p = new Point(2,4);
   4 : p.x
{% endhighlight %}

`/list` is much more powerful. It shows snipped ids, so I can ask for specific one and as you can see, I can see also dropped variable `a`
{% highlight java %}
jshell> /list 3

   3 : Point p = new Point(2,4);

jshell> /list 1

   1 : int a = 5
{% endhighlight %}

To see what variables or methods I have defined, use `/v` or `/m`. For redo all steps use `/reload` and if you want to start from the beginning with the clean sheet, simple `/reset` do so.

{% highlight java %}
jshell> int a = 5
a ==> 5

jshell> int b = 6
b ==> 6

jshell> int add(int a, int b) { return a + b; }
|  created method add(int,int)

jshell> add(a, b)
$4 ==> 11

jshell> /v
|    int a = 5
|    int b = 6
|    int $4 = 11

jshell> /m
|    printf (String,Object...)void
|    add (int,int)int

jshell> /list

   1 : int a = 5;
   2 : int b = 6;
   3 : int add(int a, int b) { return a + b; }
   4 : add(a, b)

jshell> /reload
|  Restarting and restoring state.
-: int a = 5;
-: int b = 6;
-: int add(int a, int b) { return a + b; }
-: add(a, b)

jshell> /list

   1 : int a = 5;
   2 : int b = 6;
   3 : int add(int a, int b) { return a + b; }
   4 : add(a, b)

jshell> /reset
|  Resetting state.

jshell> /v

jshell> /m
|    printf (String,Object...)void

jshell> /list


{% endhighlight %}

### /edit
Let's say we want to change some variable/method. We can simply assign new value, like you probably expect
{% highlight java %}
jshell> int i = 50
i ==> 50

jshell> int i = 55
i ==> 55

jshell> i = 60
i ==> 60

jshell> i
i ==> 60

jshell> void print() { System.out.println("Hello"); }
|  created method print()

jshell> print()
Hello

jshell> void print() { System.out.println("Hello World!"); }
|  modified method print()

jshell> print()
Hello World!
{% endhighlight %}

or we can use `/edit`. It opens beautifully ugly window
{% highlight java %}
jshell> /edit
{% endhighlight %}
![jshellEditPad]({{ site.url }}/assets/jshell/jshellEditPad.png)

You can see all history there, but when you hit accept, it just evaluate changed snippets (lines). It won't reevaluate all affected snippets, which does make sense. So for example when I have 
{% highlight java %}
int a = 5;
int b = 6;
int c = a + b;
{% endhighlight %}
and I change a to `int a = 4`, `c` will be still `11`.

It's possible to edit just one variable/method with simple `/edit a`.


### /save /open
Last thing I want to show you is saving/reading to/from files. It's really easy and useful. To save current session enter `/save [filename]`

{% highlight java %}
jshell> int a = 5
a ==> 5

jshell> int b = 6
b ==> 6

jshell> int c = a + b
c ==> 11

jshell> /save example
{% endhighlight %}

This creates in current folder file with name "example" which looks as simple as you might expect
{% highlight java %}
mvala[~] Î» cat example 
int a = 5;
int b = 6;
int c = a + b;
{% endhighlight %}

and reading file is the same
{% highlight java %}
jshell> /open example

jshell> /v
|    int a = 5
|    int b = 6
|    int c = 11

jshell> /list

   1 : int a = 5;
   2 : int b = 6;
   3 : int c = a + b;
{% endhighlight %}

## Conclusion

Enough for now. We've seen some customization, checked tab completion, file save and read and few other **JShell** commands. Next time stuff like *classpath*, *imports*, ...

[first part]: /java9-jshell-1
